{"metadata":{"roleHeading":"Article","role":"article","images":[{"type":"icon","identifier":"logo.png"}],"title":"WebSocket Server Upgrade"},"schemaVersion":{"patch":0,"minor":3,"major":0},"hierarchy":{"paths":[["doc:\/\/com.opticalaberration.hummingbird\/documentation\/index"]]},"abstract":[{"type":"text","text":"Support for upgrading HTTP1 connections to WebSocket."}],"kind":"article","identifier":{"url":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/WebSocketServerUpgrade","interfaceLanguage":"swift"},"seeAlsoSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketInboundStream","doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketOutboundWriter"],"anchor":"Related-Documentation","title":"Related Documentation"},{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/WebSocketClientGuide"],"anchor":"WebSockets","generated":true,"title":"WebSockets"}],"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","type":"heading","level":2,"anchor":"Overview"},{"inlineContent":[{"text":"Before a HTTP connection can be upgraded to a WebSocket connection a server must process an initial upgrade request and respond with a switching protocols response. HummingbirdWebSocket provides a server child channel setup that implements this for you with entry points to decide whether the upgrade should occur and then how to handle the upgraded WebSocket connection.","type":"text"}],"type":"paragraph"},{"text":"Setup","type":"heading","level":2,"anchor":"Setup"},{"inlineContent":[{"text":"You can access this by setting the ","type":"text"},{"type":"codeVoice","code":"server"},{"text":" parameter in ","type":"text"},{"type":"codeVoice","code":"Application.init()"},{"text":" to ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/HTTPServerBuilder\/http1WebSocketUpgrade(configuration:additionalChannelHandlers:shouldUpgrade:)-3n8zf"},{"text":". This is initialized with a closure that returns either ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdWebSocket\/ShouldUpgradeResult\/dontUpgrade"},{"text":" to not perform the WebSocket upgrade or ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdWebSocket\/ShouldUpgradeResult\/upgrade(_:_:)"},{"text":" along with the closure handling the WebSocket connection.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let app = Application(","    router: router,","    server: .http1WebSocketUpgrade { request, channel, logger in","        \/\/ upgrade if request URI is \"\/ws\"","        guard request.uri == \"\/ws\" else { return .dontUpgrade }","        \/\/ The upgrade response includes the headers to include in the response and ","        \/\/ the WebSocket handler","        return .upgrade([:]) { inbound, outbound, context in","            for try await frame in inbound {","                \/\/ send \"Received\" for every frame we receive","                try await outbound.write(.text(\"Received\"))","            }","        }","    }",")"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Alternatively you can provide a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router"},{"type":"text","text":" using a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContext"},{"type":"text","text":" that conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdWebSocket\/WebSocketRequestContext"},{"type":"text","text":". The router can be the same router as you use for your HTTP requests, but it is preferable to use a separate router. Using a router means you can add middleware to process the initial upgrade request before it is handled eg for authenticating the request."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Setup WebSocket router","let wsRouter = Router(context: BasicWebSocketRequestContext.self)","\/\/ add middleware","wsRouter.middlewares.add(LogRequestsMiddleware())","wsRouter.middlewares.add(BasicAuthenticator())","\/\/ An upgrade only occurs if a WebSocket path is matched","wsRouter.ws(\"\/ws\") { request, context in","    \/\/ allow upgrade","    .upgrade([:])","} onUpgrade: { inbound, outbound, context in","    for try await frame in inbound {","        \/\/ send \"Received\" for every frame we receive","        try await outbound.write(.text(\"Received\"))","    }","}","let app = Application(","    router: router,","    server: .http1WebSocketUpgrade(webSocketRouter: wsRouter)",")"],"type":"codeListing"},{"text":"WebSocket Handler","type":"heading","level":2,"anchor":"WebSocket-Handler"},{"inlineContent":[{"text":"The WebSocket handle function has three parameters: an inbound sequence of WebSocket frames ( ","type":"text"},{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketInboundStream","isActive":true,"type":"reference"},{"text":"), an outbound WebSocket frame writer (","type":"text"},{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketOutboundWriter","isActive":true,"type":"reference"},{"text":") and a context parameter. The WebSocket is kept open as long as you don’t leave this function. PING, PONG and CLOSE frames are managed internally. As soon as you leave this function it will perform the CLOSE handshake. If you want to send a regular PING keep-alive you can control that via the WebSocket configuration. By default servers send a PING every 30 seconds.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Below is a simple input and response style connection a frame is read from the inbound stream, processed and then a response is written back. If the connection is closed the inbound stream will end and we exit the function.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["wsRouter.ws(\"\/ws\") { inbound, outbound, context in","    for try await frame in inbound {","        let response = await process(frame)","        try await outbound.write(response)","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"If the reading and writing from your WebSocket connection are asynchronous then you can use a structured ","type":"text"},{"code":"TaskGroup","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["wsRouter.ws(\"\/ws\") { inbound, outbound, context in","    try await withThrowingTaskGroup(of: Void.self) { group in","        group.addTask {","            for try await frame in inbound {","                await process(frame)","            }","        }","        group.addTask {","            for await frame in outboundFrameSource {","                try await outbound.write(frame)","            }","        }","        try await group.next()","        \/\/ once one task has finished, cancel the other","        group.cancelAll()","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"You should not use unstructured Tasks to manage your WebSockets. If you use an unstructured Task you increase the likelyhood of processing a WebSocket connection that has already been closed.","type":"text"}],"type":"paragraph"},{"text":"Frames and messages","type":"heading","level":3,"anchor":"Frames-and-messages"},{"inlineContent":[{"text":"A WebSocket message can be split across multiple WebSocket frames. The last frame indicated by the ","type":"text"},{"code":"FIN","type":"codeVoice"},{"text":" flag being set to true. If you want to work with messages instead of frames you can convert the inbound stream of frames to a stream of messages using ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketInboundStream\/messages(maxSize:)","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["wsRouter.ws(\"\/ws\") { inbound, outbound, context in","    \/\/ We have set the maximum size of a message to be 1MB. If we don't set","    \/\/ a maximum size a client could keep sending us frames until we ran ","    \/\/ out of memory.","    for try await message in inbound.messages(maxSize: 1024*1024) {","        let response = await process(message)","        try await outbound.write(response)","    }","}"],"type":"codeListing"},{"text":"WebSocket Context","type":"heading","level":3,"anchor":"WebSocket-Context"},{"inlineContent":[{"type":"text","text":"The context that is passed to the WebSocket handler along with the inbound stream and outbound writer is different depending on how you setup your WebSocket connection. In most cases the context only holds a "},{"type":"codeVoice","code":"Logger"},{"type":"text","text":" for logging output."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"But if the WebSocket was setup with a router, then the context also includes the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/Request"},{"type":"text","text":" that initiated the WebSocket upgrade and the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContext"},{"type":"text","text":" from that same call. With this you can configure your WebSocket connection based on details from the initial request. Below we are using a query parameter to add a named WebSocket to a connection manager"}],"type":"paragraph"},{"syntax":"swift","code":["wsRouter.ws(\"chat\") { request, _ in","    \/\/ only allow upgrade if username query parameter exists","    guard request.uri.queryParameters[\"username\"] != nil else {","        return .dontUpgrade","    }","    return .upgrade([:])","} onUpgrade: { inbound, outbound, context in","    \/\/ only allow upgrade to continue if username query parameter exists","    guard let name = context.request.uri.queryParameters[\"username\"] else { return }","    await connectionManager.manageUser(name: String(name), inbound: inbound, outbound: outbound)","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Alternatively you could use the "},{"type":"codeVoice","code":"RequestContext"},{"type":"text","text":" to extract authentication data to get the user’s name."}],"type":"paragraph"}]}],"sections":[],"references":{"doc://com.opticalaberration.hummingbird/documentation/WSCore/WebSocketInboundStream":{"kind":"symbol","navigatorTitle":[{"text":"WebSocketInboundStream","kind":"identifier"}],"type":"topic","title":"WebSocketInboundStream","url":"\/documentation\/wscore\/websocketinboundstream","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketInboundStream","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WebSocketInboundStream","kind":"identifier"}],"abstract":[{"text":"Inbound WebSocket data frame AsyncSequence","type":"text"}],"role":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdWebSocket/ShouldUpgradeResult/upgrade(_:_:)":{"kind":"symbol","abstract":[],"type":"topic","url":"\/documentation\/hummingbirdwebsocket\/shouldupgraderesult\/upgrade(_:_:)","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"upgrade"},{"kind":"text","text":"("},{"preciseIdentifier":"s:9HTTPTypes10HTTPFieldsV","kind":"typeIdentifier","text":"HTTPFields"},{"kind":"text","text":", "},{"preciseIdentifier":"s:20HummingbirdWebSocket19ShouldUpgradeResultO5Valuexmfp","kind":"typeIdentifier","text":"Value"},{"kind":"text","text":")"}],"title":"ShouldUpgradeResult.upgrade(_:_:)","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdWebSocket\/ShouldUpgradeResult\/upgrade(_:_:)","role":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/WSCore/WebSocketInboundStream/messages(maxSize:)":{"kind":"symbol","type":"topic","role":"symbol","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketInboundStream\/messages(maxSize:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"messages","kind":"identifier"},{"text":"(","kind":"text"},{"text":"maxSize","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Int","kind":"typeIdentifier","preciseIdentifier":"s:Si"},{"text":") -> ","kind":"text"},{"text":"WebSocketInboundMessageStream","kind":"typeIdentifier","preciseIdentifier":"s:6WSCore29WebSocketInboundMessageStreamV"}],"abstract":[{"text":"Convert to AsyncSequence of WebSocket messages","type":"text"}],"title":"messages(maxSize:)","url":"\/documentation\/wscore\/websocketinboundstream\/messages(maxsize:)"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdWebSocket/WebSocketRequestContext":{"kind":"symbol","title":"WebSocketRequestContext","role":"symbol","abstract":[{"type":"text","text":"Request context protocol requirement for routers that support WebSockets"}],"url":"\/documentation\/hummingbirdwebsocket\/websocketrequestcontext","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WebSocketRequestContext","kind":"identifier"}],"navigatorTitle":[{"text":"WebSocketRequestContext","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdWebSocket\/WebSocketRequestContext"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdCore/HTTPServerBuilder/http1WebSocketUpgrade(configuration:additionalChannelHandlers:shouldUpgrade:)-3n8zf":{"kind":"symbol","abstract":[{"type":"text","text":"HTTP1 channel builder supporting a websocket upgrade"}],"type":"topic","url":"\/documentation\/hummingbirdcore\/httpserverbuilder\/http1websocketupgrade(configuration:additionalchannelhandlers:shouldupgrade:)-3n8zf","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"http1WebSocketUpgrade"},{"kind":"text","text":"("},{"kind":"externalParam","text":"configuration"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"WebSocketServerConfiguration","preciseIdentifier":"s:20HummingbirdWebSocket0bC19ServerConfigurationV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"additionalChannelHandlers"},{"kind":"text","text":": "},{"kind":"attribute","text":"@autoclosure"},{"text":" () -> [","kind":"text"},{"text":"any","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RemovableChannelHandler","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore23RemovableChannelHandlerP"},{"text":"], ","kind":"text"},{"text":"shouldUpgrade","kind":"externalParam"},{"text":": (","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:9HTTPTypes11HTTPRequestV","text":"HTTPRequest"},{"kind":"text","text":", "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore7ChannelP","text":"Channel"},{"kind":"text","text":", "},{"kind":"typeIdentifier","preciseIdentifier":"s:7Logging6LoggerV","text":"Logger"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"ShouldUpgradeResult","kind":"typeIdentifier","preciseIdentifier":"s:20HummingbirdWebSocket19ShouldUpgradeResultO"},{"text":"<","kind":"text"},{"text":"WebSocketDataHandler","kind":"typeIdentifier","preciseIdentifier":"s:6WSCore20WebSocketDataHandlera"},{"text":"<","kind":"text"},{"preciseIdentifier":"s:20HummingbirdWebSocket05HTTP1bC14UpgradeChannelV","kind":"typeIdentifier","text":"HTTP1WebSocketUpgradeChannel"},{"kind":"text","text":"."},{"preciseIdentifier":"s:20HummingbirdWebSocket05HTTP1bC14UpgradeChannelV7ContextV","kind":"typeIdentifier","text":"Context"},{"kind":"text","text":">>) -> "},{"preciseIdentifier":"s:15HummingbirdCore17HTTPServerBuilderV","kind":"typeIdentifier","text":"HTTPServerBuilder"}],"title":"http1WebSocketUpgrade(configuration:additionalChannelHandlers:shouldUpgrade:)","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/HTTPServerBuilder\/http1WebSocketUpgrade(configuration:additionalChannelHandlers:shouldUpgrade:)-3n8zf","role":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdCore/Request":{"kind":"symbol","type":"topic","role":"symbol","navigatorTitle":[{"text":"Request","kind":"identifier"}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/Request","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Request","kind":"identifier"}],"abstract":[{"type":"text","text":"Holds all the values required to process a request"}],"title":"Request","url":"\/documentation\/hummingbirdcore\/request"},"logo.png":{"type":"image","alt":null,"identifier":"logo.png","variants":[{"url":"\/images\/com.opticalaberration.hummingbird\/logo.png","traits":["1x","light"]}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/Router":{"navigatorTitle":[{"kind":"identifier","text":"Router"}],"title":"Router","abstract":[{"text":"Create rules for routing requests and then create ","type":"text"},{"code":"Responder","type":"codeVoice"},{"text":" that will follow these rules.","type":"text"}],"type":"topic","url":"\/documentation\/hummingbird\/router","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Router"}],"role":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/WebSocketClientGuide":{"kind":"article","url":"\/documentation\/hummingbird\/websocketclientguide","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/WebSocketClientGuide","images":[{"type":"icon","identifier":"logo.png"}],"title":"WebSocket Client","type":"topic","abstract":[{"type":"text","text":"Connecting to WebSocket servers."}],"role":"article"},"doc://com.opticalaberration.hummingbird/documentation/WSCore/WebSocketOutboundWriter":{"url":"\/documentation\/wscore\/websocketoutboundwriter","type":"topic","role":"symbol","navigatorTitle":[{"text":"WebSocketOutboundWriter","kind":"identifier"}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/WSCore\/WebSocketOutboundWriter","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WebSocketOutboundWriter","kind":"identifier"}],"abstract":[{"text":"Outbound websocket writer","type":"text"}],"kind":"symbol","title":"WebSocketOutboundWriter"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdWebSocket/ShouldUpgradeResult/dontUpgrade":{"kind":"symbol","type":"topic","abstract":[],"url":"\/documentation\/hummingbirdwebsocket\/shouldupgraderesult\/dontupgrade","title":"ShouldUpgradeResult.dontUpgrade","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdWebSocket\/ShouldUpgradeResult\/dontUpgrade","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"dontUpgrade"}],"role":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/index":{"kind":"article","title":"Hummingbird Documentation","role":"collection","abstract":[{"text":"Documentation for Hummingbird the lightweight, flexible, modern server framework.","type":"text"}],"url":"\/documentation\/index","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/index","type":"topic","images":[{"identifier":"logo.png","type":"icon"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RequestContext":{"navigatorTitle":[{"kind":"identifier","text":"RequestContext"}],"title":"RequestContext","abstract":[{"type":"text","text":"Protocol that all request contexts should conform to. A RequestContext is a statically typed metadata container for information"},{"type":"text","text":" "},{"type":"text","text":"that is associated with a "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/Request"},{"type":"text","text":", and is therefore instantiated alongside the request."}],"type":"topic","url":"\/documentation\/hummingbird\/requestcontext","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContext","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"RequestContext"}],"role":"symbol"}}}