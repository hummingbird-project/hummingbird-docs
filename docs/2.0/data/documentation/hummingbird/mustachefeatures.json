{"metadata":{"title":"Mustache Features","roleHeading":"Article","role":"article","images":[{"type":"icon","identifier":"logo.png"}]},"hierarchy":{"paths":[["doc:\/\/com.opticalaberration.hummingbird\/documentation\/index"]]},"kind":"article","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MustacheFeatures"},"sections":[],"primaryContentSections":[{"content":[{"text":"Lambdas","level":2,"type":"heading","anchor":"Lambdas"},{"type":"paragraph","inlineContent":[{"text":"The library provides support for mustache lambdas via the type ","type":"text"},{"code":"MustacheLambda","type":"codeVoice"},{"text":".","type":"text"}]},{"text":"Rendering variables","type":"heading","level":3,"anchor":"Rendering-variables"},{"type":"paragraph","inlineContent":[{"text":"The mustache manual section for mustache lambdas when rendered as variables states.","type":"text"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If any value found during the lookup is a callable object, such as a function or lambda, this object will be invoked with zero arguments. The value that is returned is then used instead of the callable object itself."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An optional part of the specification states that if the final key in the name is a lambda that returns a string, then that string should be rendered as a Mustache template before interpolation. It will be rendered using the default delimiters (see Set Delimiter below) against the current context."}]}],"type":"aside","name":"Manual"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift Mustache supports both parts of the specification of lambdas when rendered as variables. Instead of a callable object, swift-mustache requires the type to be a "},{"type":"codeVoice","code":"MustacheLambda"},{"type":"text","text":" initialized with a closure that has no parameters."}]},{"type":"aside","name":"Note","content":[{"inlineContent":[{"text":"If the lambda is rendered as a variable and you supply a closure that accepts a ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" then the supplied "},{"type":"codeVoice","code":"String"},{"text":" is empty.","type":"text"}],"type":"paragraph"}],"style":"note"},{"type":"paragraph","inlineContent":[{"text":"Below we have a couple of examples of rendering mustache lambdas as variables. One returning a tuple and one returning a ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" which is then parsed as a template. If we have the following object"}]},{"type":"codeListing","syntax":"swift","code":["let object: [String: Any] = [","    \"year\": 1970,","    \"month\": 1,","    \"day\": 1,","    \"time\": MustacheLambda {","        (hour: 0, minute: 0, second: 0)","    },","    \"today\": MustacheLambda { _ in","        return \"{{year}}-{{month}}-{{day}}\"","    },","]"]},{"inlineContent":[{"type":"text","text":"and the following mustache template"}],"type":"paragraph"},{"type":"codeListing","code":["let mustache = \"\"\"","    * {{time.hour}}","    * {{today}}","    \"\"\"","let template = try MustacheTemplate(string: mustache)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"then "},{"code":"template.render(object)","type":"codeVoice"},{"text":" will output","type":"text"}]},{"type":"codeListing","code":["* 0","* 1970-1-1"],"syntax":null},{"inlineContent":[{"text":"In this example the first part of the template calls lambda ","type":"text"},{"type":"codeVoice","code":"time"},{"type":"text","text":" and then uses "},{"code":"hour","type":"codeVoice"},{"text":" from the return object. In the second part the ","type":"text"},{"type":"codeVoice","code":"today"},{"type":"text","text":" lambda returns a string which is then parsed as mustache and renders the year."}],"type":"paragraph"},{"text":"Rendering sections","type":"heading","anchor":"Rendering-sections","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The mustache manual section for mustache lambdas when rendered as a section states."}]},{"style":"note","type":"aside","name":"Manual","content":[{"type":"paragraph","inlineContent":[{"text":"When any value found during the lookup is a callable object, such as a function or lambda, the object will be invoked and passed the block of text. The text passed is the literal block, unrendered. {{tags}} will not have been expanded.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An optional part of the specification states that if the final key in the name is a lambda that returns a string, then that string replaces the content of the section. It will be rendered using the same delimiters as the original section content. In this way you can implement filters or caching."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift Mustache does not support the part of the specification of lambdas when rendered as sections pertaining to delimiters. As with variables, instead of a callable object, swift-mustache requires the type to be a "},{"code":"MustacheLambda","type":"codeVoice"},{"type":"text","text":" which can be initialized with either a closure that accepts a String or nothing. When the lambda is rendered as a section the supplied "},{"code":"String","type":"codeVoice"},{"text":" is the contents of the section.","type":"text"}]},{"inlineContent":[{"text":"If we have an object as follows","type":"text"}],"type":"paragraph"},{"code":["let object: [String: Any] = [","  \"name\": \"Willy\",","  \"wrapped\": MustacheLambda { text in","    return \"<b>\" + text + \"<\/b>\"","  }","]"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"and the following mustache template","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let mustache = \"{{#wrapped}}{{name}} is awesome.{{\/wrapped}}\"","let template = try MustacheTemplate(string: mustache)"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Then "},{"code":"template.render(object)","type":"codeVoice"},{"type":"text","text":" will output"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["<b>Willy is awesome.<\/b>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here when the "},{"type":"codeVoice","code":"wrapped"},{"text":" section is rendered the text inside the section is passed to the ","type":"text"},{"type":"codeVoice","code":"wrapped"},{"text":" lambda and the resulting text passed back is parsed as a new template.","type":"text"}]},{"anchor":"Template-inheritance-and-parents","level":2,"text":"Template inheritance and parents","type":"heading"},{"inlineContent":[{"type":"text","text":"Template inheritance allows you to override elements of an included partial. It allows you to create a base page template, or parent as it is called in the mustache manual, and override elements of it with your page content. A parent that includes overriding elements is indicated with a "},{"type":"codeVoice","code":"{{<parent}}"},{"type":"text","text":". Note this is different from the normal partial reference which uses "},{"code":">","type":"codeVoice"},{"text":". This is a section tag so needs a ending tag as well. Inside the section the tagged sections to override are added using the syntax ","type":"text"},{"code":"{{$tag}}contents{{\/tag}}","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"If your template is as follows","type":"text"}]},{"type":"codeListing","code":["{{! mypage.mustache }}","{{<base}}","{{$head}}<title>My page title<\/title>{{\/head}}","{{$body}}Hello world{{\/body}}","{{\/base}}"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"And you partial is as follows"}]},{"syntax":null,"code":["{{! base.mustache }}","<html>","<head>","{{$head}}{{\/head}}","<\/head>","<body>","{{$body}}Default text{{\/body}}","<\/body>","<\/html>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"You would get the following output when rendering ","type":"text"},{"code":"mypage.mustache","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"codeListing","code":["<html>","<head>","<title>My page title<\/title>","<\/head>","<body>","Hello world","<\/body>"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note the "},{"type":"codeVoice","code":"{{$head}}"},{"type":"text","text":" section in "},{"type":"codeVoice","code":"base.mustache"},{"type":"text","text":" is replaced with the "},{"code":"{{$head}}","type":"codeVoice"},{"type":"text","text":" section included inside the "},{"type":"codeVoice","code":"{{<base}}"},{"text":" partial reference from ","type":"text"},{"code":"mypage.mustache","type":"codeVoice"},{"text":". The same occurs with the ","type":"text"},{"type":"codeVoice","code":"{{$body}}"},{"type":"text","text":" section. In that case though a default value is supplied for the situation where a "},{"type":"codeVoice","code":"{{$body}}"},{"text":" section is not supplied.","type":"text"}]},{"level":2,"anchor":"PragmasConfiguration-variables","text":"Pragmas\/Configuration variables","type":"heading"},{"inlineContent":[{"text":"The syntax ","type":"text"},{"code":"{{% var: value}}","type":"codeVoice"},{"type":"text","text":" can be used to set template rendering configuration variables specific to Hummingbird Mustache. The only variable you can set at the moment is "},{"code":"CONTENT_TYPE","type":"codeVoice"},{"text":". This can be set to either to ","type":"text"},{"type":"codeVoice","code":"HTML"},{"text":" or ","type":"text"},{"code":"TEXT","type":"codeVoice"},{"text":" and defines how variables are escaped. A content type of ","type":"text"},{"code":"TEXT","type":"codeVoice"},{"text":" means no variables are escaped and a content type of ","type":"text"},{"code":"HTML","type":"codeVoice"},{"type":"text","text":" will do HTML escaping of the rendered text. The content type defaults to "},{"code":"HTML","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Given input object "},{"type":"codeVoice","code":"<>"},{"type":"text","text":", template"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["{{%CONTENT_TYPE: HTML}}{{.}}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"will render as "},{"code":"&lt;&gt;","type":"codeVoice"},{"type":"text","text":" and"}]},{"syntax":null,"type":"codeListing","code":["{{%CONTENT_TYPE: TEXT}}{{.}}"]},{"inlineContent":[{"text":"will render as ","type":"text"},{"type":"codeVoice","code":"<>"},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Transforms","level":2,"type":"heading","text":"Transforms"},{"type":"paragraph","inlineContent":[{"text":"Transforms are specific to this implementation of Mustache. They are similar to Lambdas but instead of generating rendered text they allow you to transform an object into another. Transforms are formatted as a function call inside a tag eg","type":"text"}]},{"type":"codeListing","code":["{{uppercase(string)}}"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"They can be applied to variable, section and inverted section tags. If you apply them to a section or inverted section tag the transform name should be included in the end section tag as well eg"}]},{"code":["{{#sorted(array)}}{{.}}{{\/sorted(array)}}"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The library comes with a series of transforms for the Swift standard objects."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"String\/Substring"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"capitalized: Return string with first letter capitalized"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"lowercase: Return lowercased version of string"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"uppercase: Return uppercased version of string"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"reversed: Reverse string","type":"text"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Int\/UInt\/Int8\/Int16…","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"equalzero: Returns if equal to zero","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"plusone: Add one to integer","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"minusone: Subtract one from integer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"odd: return if integer is odd","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"even: return if integer is even","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Array","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"first: Return first element of array"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"last: Return last element of array"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"count: Return number of elements in array","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"empty: Returns if array is empty"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"reversed: Reverse array"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"sorted: If the elements of the array are comparable sort them","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Dictionary"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"count: Return number of elements in dictionary","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"empty: Returns if dictionary is empty"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"enumerated: Return dictionary as array of key, value pairs"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"sorted: If the keys are comparable return as array of key, value pairs sorted by key"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a transform is applied to an object that doesn’t recognise it then "},{"code":"nil","type":"codeVoice"},{"text":" is returned.","type":"text"}]},{"anchor":"Sequence-context-transforms","level":3,"text":"Sequence context transforms","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Sequence context transforms are transforms applied to the current position in the sequence. They are formatted as a function that takes no parameter eg","type":"text"}]},{"type":"codeListing","code":["{{#array}}{{.}}{{^last()}}, {{\/last()}}{{\/array}}"],"syntax":null},{"inlineContent":[{"text":"This will render an array as a comma separated list. The inverted section of the ","type":"text"},{"code":"last()","type":"codeVoice"},{"type":"text","text":" transform ensures we don’t add a comma after the last element."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The following sequence context transforms are available","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"first: Is this the first element of the sequence","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"last: Is this the last element of the sequence"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"index: Returns the index of the element within the sequence","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"odd: Returns if the index of the element is odd"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"even: Returns if the index of the element is even","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","text":"Custom transforms","level":3,"anchor":"Custom-transforms"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can add transforms to your own objects. Conform the object to "},{"code":"MustacheTransformable","type":"codeVoice"},{"text":" and provide an implementation of the function ","type":"text"},{"code":"transform","type":"codeVoice"},{"text":". eg","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Object: MustacheTransformable {","    let either: Bool","    let or: Bool","    ","    func transform(_ name: String) -> Any? {","        switch name {","        case \"eitherOr\":","            return either || or","        default:","            break","        }","        return nil","    }","}"]},{"inlineContent":[{"type":"text","text":"When we render an instance of this object with "},{"type":"codeVoice","code":"either"},{"type":"text","text":" or "},{"code":"or","type":"codeVoice"},{"type":"text","text":" set to true using the following template it will render “Success”."}],"type":"paragraph"},{"code":["{{#eitherOr(object)}}Success{{\/eitherOr(object)}}"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"With this we have got around the fact it is not possible to do logical OR statements in Mustache."}],"type":"paragraph"}],"kind":"content"}],"abstract":[{"type":"text","text":"An overview of the features of swift-mustache."}],"seeAlsoSections":[{"title":"Related Documentation","anchor":"Related-Documentation","identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Mustache\/MustacheTemplate","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Mustache\/MustacheLibrary"]},{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MustacheSyntax"],"title":"Mustache","generated":true,"anchor":"Mustache"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"references":{"doc://com.opticalaberration.hummingbird/documentation/Mustache/MustacheLibrary":{"url":"\/documentation\/mustache\/mustachelibrary","title":"MustacheLibrary","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"MustacheLibrary","kind":"identifier"}],"navigatorTitle":[{"text":"MustacheLibrary","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"Class holding a collection of mustache templates."}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Mustache\/MustacheLibrary","role":"symbol"},"logo.png":{"identifier":"logo.png","type":"image","variants":[{"url":"\/images\/com.opticalaberration.hummingbird\/logo.png","traits":["1x","light"]}],"alt":null},"doc://com.opticalaberration.hummingbird/documentation/index":{"title":"Hummingbird Documentation","role":"collection","abstract":[{"type":"text","text":"Documentation for Hummingbird the lightweight, flexible, modern server framework."}],"kind":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/index","images":[{"type":"icon","identifier":"logo.png"}],"url":"\/documentation\/index","type":"topic"},"doc://com.opticalaberration.hummingbird/documentation/Mustache/MustacheTemplate":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Mustache\/MustacheTemplate","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"MustacheTemplate"}],"kind":"symbol","abstract":[{"type":"text","text":"Class holding Mustache template"}],"title":"MustacheTemplate","navigatorTitle":[{"kind":"identifier","text":"MustacheTemplate"}],"url":"\/documentation\/mustache\/mustachetemplate","type":"topic","role":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/MustacheSyntax":{"images":[{"identifier":"logo.png","type":"icon"}],"url":"\/documentation\/hummingbird\/mustachesyntax","kind":"article","type":"topic","abstract":[{"text":"Overview of Mustache Syntax","type":"text"}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MustacheSyntax","title":"Mustache Syntax","role":"article"}}}